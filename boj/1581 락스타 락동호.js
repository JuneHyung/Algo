/**
 * 1581 락스타 락동호
 * 빠르게 시작해 빠르게 끝나는 노래를 FF개 만듬.
 * 빠르게 시작해 느리게 끝나는 노래를 FS개 만듬
 * 느리게 시작해 빠르게 끝나는 노래를 SF개 만듬
 * 느리게 시작해 느리게 끝나는 노래를 SS개 만들었다.
 * 모든 노래는 2번 이상 등장할 수 없다.
 * 
 * 제한 사항
 * 1. 빠르게 시작하는 노래는 반드시 빠르게 끝나는 노래 바로 다음에 와야함.
 * 2. 느리게 시작하는 노래는 반드시 느리게 끝나는 노래 바로 다음에 와야함.
 * 3. 동호가 녹음한 노래 중 빠르게 시작하는 노래가 1개라도 있다면,
 * 앨범의 가장 첫 곡은 빠르게 시작하는 곡이어야 한다.
 * 빠르게 시작하는 노래가 하나도 없다면 이 제한은 무시해도 된다.
 * 
 * FF, FS, SF, SS가 주어질 때 제한을 어기지않고, 최대 몇 곡을 실을 수 있는지 출력
 * FF, FS, SF, SS는 0이상,  1000이하
 * 4종류 중 하나는 0보다 크다. => 1개 이상은 무조건 있다.
 * 
 * ff와 fs는 ff와 sf뒤에 와야한다.
 * sf와 ss는 ss와 fs뒤에 와야한다.
 * 
 * ------------------------------------------------------------------------------------------------------------------------------
 * 
 * 1. 모든 경우 생각하기
 * 각 곡의 종류에 대한 배열을 만들어 순열을 구하고, 순열들을 돌면서 체크하여, 조건에 만족하는 노래의 순열의 최대값을 리턴.
 * => 메모리 초과
 * ------------------------------------------------------------------------------------------------------------------------------
 * 2. 경우 나누기 - 아래 경우들을 생각해내는것이 어려운 문제였다. (답지 참고함)
 * 경우 생각 하기
 * 1. 빠르게 시작하는 노래가 없는 경우 (ff===0 && fs===0)
 * SS는 개수 상관없이 붙이기 가능. (SS개)
 * SF는 맨 끝에 최대 한 개만 올 수 있다.
 * -> 느리게 시작하면 느리게 와야하니까, SF가 오는 순간 ff, fs가 와야함.
 * -> SF가 없을 수도 이있으니 SF와 1의 최소값을 구해야함.
 * 최대 곡 개수는 SS + min(SF, 1);
 * 
 * 2. 빠르게 시작하는 노래는 있지만, 빠르게 시작해 느리게 끝나는 노래가 없는 경우 (fs===0)
 * FF가 0이 아니지만, FS = 0인 경우.
 * FF만 계속 붙일 수 있다.
 * 최대 갯수는 FF
 * 
 * 3. 그 외
 * 시작과 끝이 같은 타입의 노래는 얼마든지 아무렇게 붙일 수 있다.
 * 시작과 끝이 다른 타입의 노래를 최대 몇개까지 뽑을 수 있는지 생각하기.
 * F - S - F - S - ... 번갈아 진행됨.
 * 3-1. FS > SF
 * F - S - ... - F 순으로 진행되는게 최대
 * S -> F : SF번
 * F -> S : SF + 1번
 * 최대 곡 개수는 FF + SS + 2*SF + 1
 * 
 * 3-2. SF >= FS
 * F - S - ... - S 순으로 진행되는 것이 최대
 * F -> S : FS번
 * S -> F : FS번
 * 최대 곡 개수는 FF + SS + 2*FS
 */

// const fs = require('fs')
// const input = fs.readFileSync('/dev/stdin').toString().trim();
const input = '100 0 0 200'
const [FF, FS, SF, SS] = input.split(' ').map(Number)

const solution = (ff, fs, sf, ss) => { 
  if (ff === 0 && fs === 0) return ss + Math.min(sf, 1);
  else if (fs === 0) return ff;
  else if (fs > sf) return ff + ss + (2 * sf + 1);
  else return ff + ss + 2 * fs;
}

console.log(solution(FF, FS, SF, SS))
