/**
 * 11729 하노이 탑 이동 순서
 * 3개의 장대가 있고,  첫 장대에 원판이 큰 순서대로 쌓여있다.
 * 다음 규칙에 따라 첫 장대에서 세번째 장대로 옮기려한다.
 * 
 * 1. 한 번에 1개의 원판만 다른 탑으로 옮길 수 있다.
 * 2. 쌓은 원판은 항상 아래가 더 커야 한다.
 * 
 * 이동 횟수는 최소로하여 필요한 이동순서를 출력하라.
 * 
 * 첫 장대에 쌓인 원판 수가 주어진다.
 * 
 * 출력 시 첫 줄에 옮긴 횟수 K
 * 둘줄부터 수행 과정을 출력한다. (A B)형태로 출력하는데, A의 가장위 원판을 B로 옮긴다는 뜻이다.
 * 
 */

const fs = require('fs')
const input = fs.readFileSync('/dev/stdin').toString().trim();
// const input = 3;
const N = Number(input);

const solution = (n) => {
  const hanoi = Array.from({ length: 3 }, () => []);
  hanoi[0] = Array.from({ length: n }, (_, i) => n - i);

  const result = [];
  const move = (from, to) => {
    const cur = hanoi[from].pop();
    hanoi[to].push(cur);

    result.push(`${from + 1} ${to + 1}`);
  }

  const dfs = (num, from, to, mid) => {
    if (num === 0) return;

    dfs(num - 1, from, mid, to);
    move(from, to);
    dfs(num - 1, mid, to, from);
  }
  dfs(n, 0, 2, 1)

  // console.log(hanoi)

  return [result.length, ...result].join('\n')
}

console.log(solution(N));

/**
 * 0 0 [3 2 1] / [] / []
 * 
 * 1 3 [3 2] / [] / [1]  | 1을 1에서 3으로 이동. (1, 1, 3, 2)
 * 1 2 [3] / [2] / [1]   | 2를 1에서 2로 이동 .(2, 1, 2, 3)
 * 3 2 [3] / [2 1] / []  | 1을 3에서 2로 이동  (1, 3, 2, 1)
 * 1 3 [] / [2 1] / [3]  | 3을 1에서 3로 이동  (3, 1, 3, 2)
 * 
 * 2 1 [1] / [2] / [3]   | 1을 2에서 1로 이동
 * 2 3 [1] / [] / [3 2]  | 2를 2에서 3으로 이동
 * 1 3 [] / [] / [3 2 1] | 1을 1에서 3으로 이동
 * 
 * GPT 힌트
 * 큰 원판이 목적지에 있기 위해선 다른 원판들이 다른 곳에 있어야한다.
 * 3을 C로 옮기고 싶다면?
 * 3, A, C, B
 * 
 * 2는 C가 아닌곳에 있어야 한다.
 * 2, A, B, C
 * 
 * 3을 옮긴다.
 * 
 * 2를 다시 C로 옮긴다.
 * 2, B, C, A
 */
/*
1개만 더 크게 생각해보기
원판이 4개면?
(원판, From, To, Mid)

0. 먼저 4를 C로 옮겨야한다. (4, A, C, B)

1. 그럼 4위의 3은 C가 아닌 곳에 있어야 함. (3, A, B, C)
1-1. 3이 B로 가기 위해서는 2는 B가 아닌 곳에 있어야 함. (2, A, C, B)
1-1-1. 2가 C로 가기 위해서는 1은 C가 아닌 곳에 있어야 함. (1, A, B, C)
1-1-1-1. 1이 B로 가기 위해서는 0이 B가 아닌 곳으로 이동. (0, A, C, B)
1-1-1-1-1. 0이면 다 옮긴 거니까 return;
1-1-1-2.  1을 A->B로 이동.
1-1-1-3. 옮긴 후 0이 B가 아닌 곳에서 다시 돌려줌. (0, C, B, A)
재귀

1-1-2. 2를 A->C로 이동.
1-1-3. 옮긴 후 1을 C가 아닌 곳에서 다시 돌려줌. (1, B, C, A);
재귀

1-2. 3을 A->B로 이동.
1-3. 옮긴 후 2를 B가 아닌 곳에서 다시 돌려줌. (2, C, B, A);
재귀
...

2. 4가 C로 이동.

3. 옮긴 후 3을 C가 아닌 곳에서 다시 돌려줌. (3, B, C, A);
3-1. 3이 C로 가기 위해서 2는 C가 아닌 곳에 있어야 함.(2, B, A, C) // 1-3에서 B로 이동함.
3-1-1. 2가 A로 가기 위해서는 1이 A가 아닌 곳에 있어야 함. (1, B, C, A)
3-1-1-1. 1이 C로 가기 위해서 0이 C가 아닌 곳으로 이동. (0, B, A, C)
3-1-1-1-1. 0이면 다 옮긴 거니까 return;
3-1-1-2. 1을 B->C로 이동.
3-1-1-3. 옮긴 후 0이 C가 아닌 곳에서 ㄷ시 돌려줌. (0, A, C, B)
재귀

3-1-2. 2를 B->A로 이동.
3-1-3. 옮긴 후 1을 a가 아닌 곳에서 다시 돌려줌.(1, C, A, B)
재귀

3-2. 3을 B->C로 이동.
3-3. 옮긴 후 2를 C가 아닌 곳에서 다시 돌려줌. (2, A, C, B)
재귀

*/

