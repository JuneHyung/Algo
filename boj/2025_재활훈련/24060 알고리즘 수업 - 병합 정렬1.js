/**
 * 24060 알고리즘 수업 - 병합 정렬1
 * N개 서로다른 양의 정수가 저장됨 배열 A가 있다.
 * 병합정렬로 오름차순 정렬할 경우 배열 A에 k번째 저장되는 수를 구하자.
 * 
 * 첫줄 배열 A크기 N 5~50만, 저장 횟수 k가 주어진다.
 * 서로다른 배열 A의 원소 A1~An이 주어진다.
 * 
 * a에 k번째 저장되는 수를 출력. 저장횟수가 k보다 작으면 -1 출력
 */
/**
 * 병합정렬
 * 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법
 * 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.
 * 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.
 * 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.
 * https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html
 */
/**
 * 의사코드 대로 작성.
 */
/**
 * 의사코드 메모
 * i<-p : i에 p를 할당하겠다는 뜻. 변수선언
 * 마지막 반복문 `while (i ≤ r)  # 결과를 A[p..r]에 저장` 에서
 * k번째의 수를 리턴 하면 될 것 같은데 의사코드과정이 안읽혀서 아래정리
 */
// const fs = require('fs')
// const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n')
const input = [
  '5 7',
  '4 5 1 3 2',
]

const [N, K] = input[0].split(' ').map(Number)
const ARR = input[1].split(' ').map(Number);

const solution = (n, k, arr) => {
  let result = -1;
  let cnt = 0;
  let tmp = []; // 병합을 위한 임시 배열

  // A[p...r]을 오름차순 정렬한다.
  const mergeSort = (arr, p, r) => {
    if (p < r) {
      let q = Math.floor((p + r) / 2); // q는 p와 r의 중간지점
      mergeSort(arr, p, q); // 전반부 정렬
      mergeSort(arr, q + 1, r); // 후반부 정렬
      merge(arr, p, q, r); // 병합
    }
  };

  // A[p..q]와 A[q+1..r]을 병합하여 A[p..r]을 오름차순 정렬된 상태로 만든다.
  // A[p..q]와 A[q+1..r]은 이미 오름차순으로 정렬되어 있다.
  const merge = (arr, p, q, r) => {
    let i = p, j = q + 1, t = 0;

    while (i <= q && j <= r) {
      if (arr[i] <= arr[j]) tmp[t++] = arr[i++];
      else tmp[t++] = arr[j++];
    }

    while (i <= q) { // 왼쪽 배열 부분이 남은 경우
      tmp[t++] = arr[i++]; // tmp[t] <- A[i]; t++; i++;
    }
    while (j <= r) { // 오른쪽 배열 부분이 남은 경우
      tmp[t++] = arr[j++]; // tmp[t] <- A[j]; t++; j++;
    }

    i = p; t = 0;
    while (i <= r) { // 결과를 A[p...r]에 저장
      arr[i] = tmp[t];
      // 추가 부분
      cnt++;
      if (cnt === k) result = arr[i];
      i++; t++;
    }
  };

  mergeSort(arr, 0, n - 1);
  return result;
};

console.log(solution(N, K, ARR));

/**
 * '5 7',
 * '4 5 1 3 2',
 * 
 * 0. mergeSort(arr, 0, n - 1);
 * q = (0+4) / 2  = 2
 * 
 * 1. mergeSort(arr, 0, 2) - 왼쪽정렬하는 부분
 * q = (0+2) / 2 = 2
 * 1-1. mergeSort(arr, 0, 1) → [4, 5]
 * 1-1-1. mergeSort(arr, 0, 0) → 크기가 1이라 종료
 * 1-1-2. mergeSort(arr, 1, 1) → 크기가 1이라 종료
 * 1-1-3. merge(arr, 0, 0, 1) → 4와 5 비교 → 정렬되어 있어 종료.
 * 1-1-3-1. 1번 저장 : 4
 * 1-1-3-2. 2번 저장 : 5
 * 1-1-3-3. arr = [4, 5, 1, 3, 2]
 * 
 * 1-2. mergeSort(arr, 2, 2) → [1] → 크기가 1이라 종료
 * 
 * 1-3. merge(arr, 0, 1, 2) → [4,5]와 [1]을 병합
 * 1-3-1. [4,5]와 [1] 비교 → [1, 4, 5]로 정렬
 * 1-3-2. 3번 저장 : 1
 * 1-3-3. 4번 저장 : 4
 * 1-3-4. 5번 저장 : 5
 * 1-3-5. arr = [1, 4, 5, 3, 2]
 * 
 * -------------------------------------------------------------------------
 * 2. mergeSort(arr, 3, 4) - 오른쪽 정렬
 * q = (3+4)/2 = 3
 * 2-1. mergeSort(arr, 3, 4) → 크기가 1이라 종료
 * 2-2. mergeSort(arr, 4, 4) → 크기가 1이라 종료
 * 2-3. merge(arr, 3, 3, 4)
 * 2-3-1. [3]과 [2] 비교 → [2, 3] 정렬.
 * 2-3-2. 6번 저장 : 2
 * 2-3-3. 7번 저장 : 3 (k=7이니 3을 저장)
 * 
 * -------------------------------------------------------------------------
 * 3. merge(arr, 0, 2, 4) - 최종 병합
 * 3-1. 왼쪽정렬 + 오른쪽정렬 비교 : [1, 4, 5] + [2, 3] 비교 → [1, 2, 3, 4, 5]
 * 3-1-1. 8번 저장 : 1
 * 3-1-1. 9번 저장 : 2
 * 3-1-2. 10번 저장 : 3
 * 3-1-3. 11번 저장 : 4
 * 3-1-4. 12번 저장 : 5
 * 
 */