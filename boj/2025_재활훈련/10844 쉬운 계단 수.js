/**
 * 10844 쉬운 계단 수
 * 45656
 * 이렇게 인접한 모든 자리 차이가 1인 수를 계단 수라한다.
 * N이 주어질때 길이가 N인 계단 수 가 총 몇개있는지 구해보자.
 * 0으로 시작하는 경우 계단수가 아니다.
 * 
 * 정답을 1000000000으로 나눈 나머지를 출력.
 * 
 * 한 자리 수도 게단수 이다.
 */
/**
 * GPT왈
 * 계속 틀리는 이유는 합을 구하고 나누지 않았기 때문이란다.
 * 마지막 reduce로 합친 후에 1000000000을 넘을 수 있기 때문에 나눠 줘야 한다.
 */
// const fs = require('fs');
// const input = fs.readFileSync('/dev/stdin').toString().trim();
const input = '30'
const N = Number(input);

const solution = (n) => {
  if (n === 1) return 9;

  // n자리 수 i로 끝나는 경우
  const dp = Array.from({ length: n + 1 }, () => Array.from({ length: 10 }, () => 0));

  dp[1] = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1];
  dp[2] = [1, 1, 2, 2, 2, 2, 2, 2, 2, 1];

  const MOD = 1_000_000_000;

  for (let i = 3; i <= n; i++) {
    for (let j = 0; j < 10; j++) {
      if (j === 0) { // 0인 경우 1만 올 수 있다.
        dp[i][j] = dp[i - 1][j + 1] % MOD;
      } else if (j === 9) { // 9인 경우 8만 올 수 있다.
        dp[i][j] = dp[i - 1][j - 1] % MOD;
      } else { // 2~8은 이전과 이후 2개씩 올 수 있다.
        dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % MOD;
      }
    }
  }

  const sum = dp[n].reduce((a, c) => (a + c) % MOD, 0);
  return sum;

}

console.log(solution(N));

/**

17

10 12
21 23
32 34
43 45
54 56
65 67
76 78
87 89
98

32
101     121 123
210 212 232 234
321 323 343 345
432 434 454 456
543 545 565 567
654 656 676 678
765 767 787 789
876 878 898
987 989

2-> 3을 작성할 때 n=2일때 끝 자리에 따라 그 다음에 오는 개수가 정해진다.
이게 규칙인 거 같음.
1~8 은 2개씩, 0, 9는 1개.

n자리수에서 i번으로 끝날 때 오는 가지 수. arr[n][i]

n자리수의 i로 끝나는 항목은 i보다 1작은경우, i보다 1큰 경우를 더한것. 

규칙 적용
*/