/**
 * 19952 인성 문제 있어??
 * 인성이는 4방향 이동이 가능하다.
 * 이동마다 1의 힘이 감소하고 0이하의 경우 못움직인다.
 * 각 격자에 장애물이 있는데 높이 정보를 가지고 있다.
 * 없으면 0
 * 현위치보다 이동위치 높이가 낮으면 문제없이 이동
 * 더 높은 곳으로 이동시 점프해야한다. (이동할곳 높이 - 현재 높이)
 * 남은 힘이 점프해야하는 높이보다 크거나 같으면 이동.
 * 아니면 이동X
 * 테스트케이스수 T
 * 세로 H ,가로 W, 장애물 수 O, 초기힘 F, 출발지 좌표정보 Xs,Ys , 도착지 좌표정보 Xe, Ye
 * 도착할 수 있으면 "잘했어!!"
 * 못하면 "인성 문제있어??"
 * 출력
 * 
 * 1. 런타임에러 => T반복 안에서 board생성하게 변경
 * 2. 틀림 => 인성이의 힘이 이동완료시 마다 감소 추가. 
 * 3. 80퍼에서 틀림 => cur을 shift할때 force가 0일때 건너뛰게 했는데 예제 정답을 잘못알아서 계속 틀린줄 ;
 * 
 */

// const fs = require('fs')
// const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n')
// const input = [
//   '2',
// '3 5 3 6 1 1 3 5',
// '1 2 8',
// '2 1 8',
//   '3 1 4',
//   '3 3 7 5 1 1 3 3',
//   '1 2 4',
//   '1 3 8',
//   '2 1 1',
//   '2 2 2',
//   '2 3 4',
//   '3 1 8',
//   '3 2 4',
// ];
const input = [
  '4',
  '2 2 0 1 1 1 2 2',
  '47 10 55 45 1 1 47 10',
  '1 2 50',
  '2 1 45',
  '3 1 45',
  '4 1 45',
  '5 1 45',
  '6 1 45',
  '7 1 45',
  '8 1 45',
  '9 1 45',
  '10 1 45',
  '11 1 45',
  '12 1 45',
  '13 1 45',
  '14 1 45',
  '15 1 45',
  '16 1 45',
  '17 1 45',
  '18 1 45',
  '19 1 45',
  '20 1 45',
  '21 1 45',
  '22 1 45',
  '23 1 45',
  '24 1 45',
  '25 1 45',
  '26 1 45',
  '27 1 45',
  '28 1 45',
  '29 1 45',
  '30 1 45',
  '31 1 45',
  '32 1 45',
  '33 1 45',
  '34 1 45',
  '35 1 45',
  '36 1 45',
  '37 1 45',
  '38 1 45',
  '39 1 45',
  '40 1 45',
  '41 1 45',
  '42 1 45',
  '43 1 45',
  '44 1 45',
  '45 1 45',
  '46 1 45',
  '47 1 45',
  '47 2 44',
  '47 3 42',
  '47 4 39',
  '47 5 35',
  '47 6 30',
  '47 7 24',
  '47 8 17',
  '47 9 9',
  '47 10 55 50 1 1 47 10',
  '1 2 50',
  '2 1 45',
  '3 1 45',
  '4 1 45',
  '5 1 45',
  '6 1 45',
  '7 1 45',
  '8 1 45',
  '9 1 45',
  '10 1 45',
  '11 1 45',
  '12 1 45',
  '13 1 45',
  '14 1 45',
  '15 1 45',
  '16 1 45',
  '17 1 45',
  '18 1 45',
  '19 1 45',
  '20 1 45',
  '21 1 45',
  '22 1 45',
  '23 1 45',
  '24 1 45',
  '25 1 45',
  '26 1 45',
  '27 1 45',
  '28 1 45',
  '29 1 45',
  '30 1 45',
  '31 1 45',
  '32 1 45',
  '33 1 45',
  '34 1 45',
  '35 1 45',
  '36 1 45',
  '37 1 45',
  '38 1 45',
  '39 1 45',
  '40 1 45',
  '41 1 45',
  '42 1 45',
  '43 1 45',
  '44 1 45',
  '45 1 45',
  '46 1 45',
  '47 1 45',
  '47 2 44',
  '47 3 42',
  '47 4 39',
  '47 5 35',
  '47 6 30',
  '47 7 24',
  '47 8 17',
  '47 9 9',
  '47 10 55 45 1 1 46 10',
  '1 2 50',
  '2 1 45',
  '3 1 45',
  '4 1 45',
  '5 1 45',
  '6 1 45',
  '7 1 45',
  '8 1 45',
  '9 1 45',
  '10 1 45',
  '11 1 45',
  '12 1 45',
  '13 1 45',
  '14 1 45',
  '15 1 45',
  '16 1 45',
  '17 1 45',
  '18 1 45',
  '19 1 45',
  '20 1 45',
  '21 1 45',
  '22 1 45',
  '23 1 45',
  '24 1 45',
  '25 1 45',
  '26 1 45',
  '27 1 45',
  '28 1 45',
  '29 1 45',
  '30 1 45',
  '31 1 45',
  '32 1 45',
  '33 1 45',
  '34 1 45',
  '35 1 45',
  '36 1 45',
  '37 1 45',
  '38 1 45',
  '39 1 45',
  '40 1 45',
  '41 1 45',
  '42 1 45',
  '43 1 45',
  '44 1 45',
  '45 1 45',
  '46 1 45',
  '47 1 45',
  '47 2 44',
  '47 3 42',
  '47 4 39',
  '47 5 35',
  '47 6 30',
  '47 7 24',
  '47 8 17',
  '47 9 9',
]

const T = Number(input.shift())

const solution = (h, w, o, f, xs, ys, xe, ye, board) => { 
  const dx = [-1, 1, 0, 0];
  const dy = [0, 0, -1, 1];
  const visited = Array.from({ length: h + 1 }, () => Array.from({ length: w + 1 }, () => false));

  const q = [[xs, ys, f]];
  visited[xs][ys] = true;

  const inRange = (x, y) => x > 0 && y > 0 && x <= h && y <= w;
  let answer = false;
  while (q.length !== 0) { 
    const [curX, curY, force] = q.shift();
    if (curX === xe && curY === ye) {
      answer = true;
      break;
    }
    if(force===0) continue;
    for (let k = 0; k < 4; k++) { 
      const nx = curX + dx[k];
      const ny = curY + dy[k];
      if (inRange(nx, ny) && !visited[nx][ny]) { 
        // 현위치보다 이동위치 높이가 낮으면 문제없이 이동
        // 더 높은 곳으로 이동시 점프해야한다. (이동할곳 높이 - 현재 높이)
        // 남은 힘이 점프해야하는 높이보다 크거나 같으면 이동.
        // 아니면 이동X
        const nextHeight = board[nx][ny];
        const curHeight = board[curX][curY];
        const subHeight = nextHeight - curHeight;
        if (curHeight >= nextHeight) {
          visited[nx][ny] = true;
          q.push([nx, ny, force - 1])
        } else if (force >= subHeight) {
          visited[nx][ny] = true;
          q.push([nx, ny, force - 1])
        }
      }
    }
  }

  return answer ? "잘했어!!" : "인성 문제있어??";
}

for (let t = 0; t < T; t++) { 
  const [H, W, O, F, XS, YS, XE, YE] = input.shift().split(' ').map(Number)
  const BOARD = Array.from({ length: H + 1 }, () => Array.from({ length: W + 1 }, () => 0))

  for (let i = 0; i < O; i++) { 
    const [x, y, h] = input.shift().split(' ').map(Number);
    BOARD[x][y] = h;
  }
  console.log(solution(H, W, O, F, XS, YS, XE, YE, BOARD))
}

